# import {GraphQLScalarType, Kind} from 'graphql'
# This "input" configures a global authorization rule to enable public access to
# all models in this schema. Learn more about authorization rules here: https://docs.amplify.aws/cli/graphql/authorization-rules
input AMPLIFY { globalAuthRule: AuthRule = { allow: public } } # FOR TESTING ONLY!

type Player @model @searchable
  # @auth(rules: [{ allow: public, operations: [read]}]) 
{
  id: ID! @primaryKey
  name: String! 
  email: AWSEmail! @index(name: "byEmail", queryField: "playerByEmail", sortKeyFields: ["name"])
  phone: AWSPhone
  about: String
  image: String
  NTRP: String
  UTR: String
  verified: Boolean! @default(value: "false")
  playerMatches: [PlayerMatch!] @hasMany
  matches: [Match] @hasMany
  ladders: [Ladder!] @manyToMany(relationName: "ladderPlayer")
  comments: [Comment!] @hasMany(indexName: "byPlayer", fields: ["id"])
}

type PlayerMatch @model @searchable {
  player: Player @belongsTo(fields: ["playerID"])
  playerID: ID! @primaryKey(sortKeyFields: ["matchID"])
                @index(
                    name: "byPlayer", 
                    queryField: "getPlayerMatchByPlayer",
                    sortKeyFields: ["playedOn"]
                )
                @index(
                    name: "byPlayerVs", 
                    queryField: "getPlayerMatchByPlayerVs", 
                    sortKeyFields: ["opponentID","matchType"]
                )
                @index(
                    name: "byPlayerWithPartner", 
                    queryField: "getPlayerMatchByPlayerWithPartner", 
                    sortKeyFields: ["partnerID"]
                )
                @index(
                    name: "byPlayerDoublesOpponentPartner", 
                    queryField: "getPlayerMatchByPlayerDoublesOpponentPartner", 
                    sortKeyFields: ["opponentPartnerID"]
                )
  partner: Player @belongsTo(fields: ["partnerID"])
  partnerID: ID 
  opponent: Player @belongsTo(fields: ["opponentID"])
  opponentID: ID!
  opponentPartner: Player @belongsTo(fields: ["opponentPartnerID"])
  opponentPartnerID: ID
  match: Match @belongsTo(fields: ["matchID"])
  matchID: ID! @index(name: "playerMatchByMatchID", queryField: "getPlayerMatchByMatchID")
  matchType: matchType! @index(name: "byMatchType", 
                               queryField: "getPlayerMatchByMatchType", 
                               sortKeyFields: ["playerID"])
  ladder: Ladder @belongsTo(fields: ["ladderID"])
  ladderID: ID! @index(name: "playerMatchByLadder", 
                       queryField: "getPlayerMatchByLadder", 
                       sortKeyFields: ["playerID"])
  win: Boolean!
  setsWon: Int! @default(value: "0")
  setsLost: Int! @default(value: "0")
  gamesWon: Int! @default(value: "0")
  gamesLost: Int! @default(value: "0")
  tiebreaksWon: Int! @default(value: "0")
  tiebreaksLost: Int! @default(value: "0")
  retired: Boolean @default(value: "false")
  playedOn: AWSDate!
}

type Match @model @searchable {
  id: ID! @primaryKey
  type: matchType!
  playedOn: AWSDate! 
  year: Int!
  winnerID: ID! @index(name: "byMatchDetails", queryField: "getMatchByDetails", sortKeyFields: ["loserID","type","ladderID","playedOn","score"])
  winner: Player @belongsTo(fields:["winnerID"])
  loserID: ID!
  loser: Player @belongsTo(fields:["loserID"]) 
  score: String!
  ladderID: ID! @index(name: "matchByLadderID", queryField: "getMatchByLadderID", sortKeyFields: ["playedOn"])
  ladder: Ladder @belongsTo(fields: ["ladderID"])
  comments: [Comment!] @hasMany(indexName: "byMatch", fields: ["id"])
  playerMatches: [PlayerMatch] @hasMany(indexName: "playerMatchByMatchID", fields: ["id"])
}

type Ladder @model @searchable {
  id: ID! @primaryKey
  matchType: matchType!  
  name: String! #@index(name: "byName", queryField: "getLadderByName")
  description: String
  level: LevelInterval
  location: Location
  # lon: Float
  # lat: Float 
  # geoIndexAnchor: Int @default(value: "1")
  #                         @index(name: "byLonLat", queryField: "getLadderByLonLat", sortKeyFields: ["lon","lat"])
  city: String
  zip: String 
  matches: [Match!] @hasMany(indexName: "matchByLadderID", fields: ["id"])
  players: [Player!] @manyToMany(relationName: "ladderPlayer")
  playerMatches: [PlayerMatch] @hasMany(indexName: "playerMatchByLadder", fields: ["id"])
}
type LevelInterval {
  min: Float
  max: Float
}
type Query {
  findNearbyLadders(
    input: FindNearbyLaddersInput!
  ): SearchableLadderConnection #@aws_iam @aws_cognito_user_pools
}
input FindNearbyLaddersInput {
  byLocation: LocationQueryInput
  limit: Int
  nextToken: String
  from: Int
}
input LocationQueryInput {
  point: LocationInput!
  radius: Int!
}
input LocationInput {
  lon: Float!
  lat: Float!
}
type SearchableLadderConnection #@aws_iam @aws_cognito_user_pools 
{
  items: [Ladder]
  nextToken: String
  total: Int
}

type Comment @model {
  id: ID! @primaryKey
  matchID: ID! @index(name: "byMatch", queryField: "getCommentsByMatch", sortKeyFields: ["postedOn"])
  match: Match @belongsTo(fields: ["matchID"])
  content: String!
  postedByID: ID! @index(name: "byPlayer", queryField: "getCommentsByPlayer", sortKeyFields: ["postedOn"])
  postedBy: Player @belongsTo(fields: ["postedByID"]) 
  postedOn: AWSDate! 
  private: Boolean @default(value: "true")
}

# type Standings @model {
#   id: ID! @primaryKey
#   playerID: ID! @index(name: "byPlayerID", queryField: "getStandingsByPlayerID", sortKeyFields: ["ladderID","isCurrent"])
#   player: Player! @hasOne
#   ladderID: ID! @index(name: "byLadderID", queryField: "getStandingsByLadderID", sortKeyFields: ["isCurrent"])
#   ladder: Ladder! @hasOne
#   wins: Int! @default(value: "0")
#   losses: Int! @default(value: "0")
#   points: Int! @default(value: "0")
#   position: Int! @default(value: "0")
#   isCurrent: String! @default(value: "true")
# }
type Standings @model {
  id: ID! @primaryKey(sortKeyFields: ["postedOn"]) # set id #cur#ladderId for current and #old#ladderId for older
  details: AWSJSON # details will be a position with a player object name/wins/losses 
  postedOn: AWSDateTime!
}

enum matchType {
  SINGLES,
  DOUBLES
}

type Location {   
  lat: Float!   
  lon: Float! 
}