# import {GraphQLScalarType, Kind} from 'graphql'
# This "input" configures a global authorization rule to enable public access to
# all models in this schema. Learn more about authorization rules here: https://docs.amplify.aws/cli/graphql/authorization-rules
input AMPLIFY { globalAuthRule: AuthRule = { allow: public } } # FOR TESTING ONLY!

type Player @model @searchable
  # @auth(rules: [{ allow: public, operations: [read]}]) 
{
  id: ID! @primaryKey
  name: String! 
  email: AWSEmail! @index(name: "byEmail", queryField: "playerByEmail")
  phone: AWSPhone
  about: String
  image: String
  NTRP: String
  UTR: String
  verified: Boolean! @default(value: "false")
  playerMatches: [PlayerMatch!] @hasMany
  ladders: [Ladder!] @manyToMany(relationName: "ladderPlayer")
  comments: [Comment!] @hasMany(indexName: "byPlayer", fields: ["id"])
}

type PlayerMatch @model @searchable {
  player: Player! @belongsTo(fields: ["playerID"])
  playerID: ID! @primaryKey(sortKeyFields: ["matchID"])
                @index(
                    name: "byPlayer", 
                    queryField: "playerMatchByPlayer"
                )
                @index(
                    name: "byPlayerVs", 
                    queryField: "playerMatchByPlayerVs", 
                    sortKeyFields: ["opponentID","matchType"]
                )
                @index(
                    name: "byPlayerWithPartner", 
                    queryField: "playerMatchByPlayerWithPartner", 
                    sortKeyFields: ["partnerID"]
                )
                @index(
                    name: "byPlayerDoublesOpponentPartner", 
                    queryField: "playerMatchByPlayerDoublesOpponentPartner", 
                    sortKeyFields: ["opponentPartnerID"]
                )
  partner: Player @belongsTo(fields: ["partnerID"])
  partnerID: ID @index(name: "byPartner", queryField: "playerMatchByPartner")
  opponent: Player! @belongsTo(fields: ["opponentID"])
  opponentID: ID! 
  opponentPartner: Player @belongsTo(fields: ["opponentPartnerID"])
  opponentPartnerID: ID
  match: Match! 
  matchID: ID! @index(name: "byMatchID", queryField: "playerMatchByMatchID")
  matchType: matchType! @index(name: "byMatchType", queryField: "playerMatchByMatchType")
  ladder: Ladder! 
  ladderID: ID! @index(name: "byLadder", queryField: "playerMatchByLadder")
  win: Boolean!
  setsWon: Int! @default(value: "0")
  setsLost: Int! @default(value: "0")
  gamesWon: Int! @default(value: "0")
  gamesLost: Int! @default(value: "0")
  tiebreaksWon: Int! @default(value: "0")
  tiebreaksLost: Int! @default(value: "0")
  retired: Boolean @default(value: "false")
}

type Match @model @searchable {
  id: ID! @primaryKey
  type: matchType!
  playedOn: AWSDate! 
  year: Int!
  winnerID: ID!
  winner: Player! 
  loserID: ID! 
  loser: Player!  
  score: String!
  ladderID: ID! @index(name: "byLadderID", queryField: "matchByLadderID")
  ladder: Ladder @belongsTo(fields: ["ladderID"])
  comments: [Comment!] @hasMany(indexName: "byMatch", fields: ["id"])
}

type Ladder @model @searchable {
  id: ID! @primaryKey
  matchType: matchType!  
  name: String! @index(name: "byName", queryField: "ladderByName")
  geoData: Location
  city: String @index(name: "byCity", queryField: "ladderByCity", sortKeyFields: ["zip"])
  zip: String 
  matches: [Match!] @hasMany
  players: [Player!] @manyToMany(relationName: "ladderPlayer")
}

type Comment @model @searchable{
  id: ID! @primaryKey
  matchID: ID! @index(name: "byMatch", sortKeyFields: ["postedOn"])
  match: Match @belongsTo(fields: ["matchID"])
  content: String!
  postedByID: ID! @index(name: "byPlayer", sortKeyFields: ["postedOn"])
  postedBy: Player @belongsTo(fields: ["postedByID"]) 
  postedOn: AWSDate! 
  private: Boolean @default(value: "true")
}

type Standings @model @searchable {
  id: ID! @primaryKey
  playerID: ID! @index(name: "byPlayerID", queryField: "standingsByPlayerID", sortKeyFields: ["ladderID","isCurrent"])
  player: Player! @hasOne
  ladderID: ID! @index(name: "byLadderID", queryField: "standingsByLadderID", sortKeyFields: ["isCurrent"])
  ladder: Ladder! @hasOne
  wins: Int! @default(value: "0")
  losses: Int! @default(value: "0")
  points: Int! @default(value: "0")
  position: Int! @default(value: "0")
  isCurrent: String! @default(value: "true")
}

enum matchType {
  SINGLES,
  DOUBLES,
  ANY
}

type Location {   
  lat: Float!   
  lon: Float! 
}